<html><head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">




















<title>Lambda Soup - Functional HTML Scraping for OCaml</title>

<link rel="canonical" href="http://aantron.github.io/lambda-soup">

<meta name="description" content="
Easy-to-use functional HTML scraping and manipulation for OCaml, inspired by
Python's Beautiful Soup.">

<meta name="author" content="Anton Bachin">

<meta name="viewport" content="width=device-width">

</head>
<body>

<div class="head">
  <div class="top-links">
    <a class="github" href="https://github.com/aantron/lambda-soup">GitHub</a>
    <a href="https://github.com/aantron/lambda-soup#installing">Installing</a>
    <a href="https://github.com/aantron/lambda-soup/blob/master/docs/CONTRIBUTING.md">
      Contributing
    </a>
  </div>

  <h1>Lambda Soup</h1>
</div>


<pre><span class="keyword">module</span> Soup: <code class="code"><span class="keyword">sig</span></code> .. <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Easy functional HTML scraping and manipulation.
<p>

    Lambda Soup is an HTML data extraction and analysis library. It supports CSS
    selectors, DOM traversals, mutation, and HTML output. This very documentation
    page was generated by <code class="code">ocamldoc</code> and then
    <a href="https://github.com/aantron/lambda-soup/blob/master/docs/postprocess.ml">
    rewritten</a> by Lambda Soup!
</p><p>

    Here are some usage examples:
</p><p>

</p><pre class="codepre"><code class="code"><span class="keyword">open</span> <span class="constructor">Soup</span>

<span class="keyword">let</span> soup = read_channel stdin |&gt; parse <span class="keyword">in</span>

<span class="comment">(* Print the page title. *)</span>
soup $ <span class="string">"title"</span> |&gt; <span class="constructor">R</span>.leaf_text |&gt; print_endline;

<span class="comment">(* Print the targets of all links. *)</span>
soup $$ <span class="string">"a[href]"</span>
|&gt; iter (<span class="keyword">fun</span> a <span class="keywordsign">-&gt;</span> print_endline (<span class="constructor">R</span>.attribute <span class="string">"href"</span> a));

<span class="comment">(* Find the first unordered list. *)</span>
<span class="keyword">let</span> ul = soup $ <span class="string">"ul"</span> <span class="keyword">in</span>

<span class="comment">(* Print the contents of all its items. *)</span>
ul $$ <span class="string">"li"</span>
|&gt; iter (<span class="keyword">fun</span> li <span class="keywordsign">-&gt;</span>
  trimmed_texts li |&gt; <span class="constructor">String</span>.concat <span class="string">""</span> |&gt; print_endline)

<span class="comment">(* Find all subsequent sibling elements of the same list. *)</span>
<span class="keyword">let</span> _ = ul $$ <span class="string">"~ *"</span> <span class="keyword">in</span>

<span class="comment">(* Find all previous sibling elements instead. *)</span>
<span class="keyword">let</span> _ = ul |&gt; previous_siblings |&gt; elements <span class="keyword">in</span>

<span class="comment">(* ... *)</span>
</code></pre>
<p>

    Lambda Soup is based around two kind of values: <em>nodes</em>, which represent
    HTML elements, text content, and so on, and <em>traversals</em>, which are lazy
    sequences of nodes. The top-level node is the <em>soup node</em> (a.k.a. document
    node), which you typically get by calling <a href="#VALparse"><code class="code">parse</code></a> on a string containing
    HTML.
</p><p>

    Once you have a node, you call <a href="#VALselect"><code class="code">select</code></a> on it to traverse to other nodes
    using CSS. There are also specialized functions, such as <a href="#VALancestors"><code class="code">ancestors</code></a> and
    <a href="#VALprevious_siblings"><code class="code">previous_siblings</code></a>, which allow you to traverse in directions that CSS
    cannot express.
</p><p>

    Traversals can be manipulated with familiar combinators such as <a href="#VALmap"><code class="code">map</code></a>,
    <a href="#VALfold"><code class="code">fold</code></a>, and <a href="#VALfilter"><code class="code">filter</code></a>. They can also be terminated early.
</p><p>

    Once you have traversed to a node you are interested in, you can extract its
    content or attributes, mutate it, cause other side effects, begin another
    traversal, or do anything else your application requires. Enjoy!
</p><p>

    Lambda Soup is developed on <a href="https://github.com/aantron/lambda-soup">
    GitHub</a> and distributed under the
    <a href="https://github.com/aantron/lambda-soup/blob/master/LICENSE.md"> BSD
    license</a>.
</p><p>

    This documentation page is for version 0.6 of the library. Documentation for
    other versions can be downloaded from the
    <a href="https://github.com/aantron/lambda-soup/releases"> releases page</a>.<br>
</p></div>


<h2 id="2_Types"><a href="#2_Types">Types</a></h2>

<pre><a href="#TYPEelement" id="TYPEelement"><span class="keyword">type</span> <code class="type"></code>element</a> </pre>


<pre><a href="#TYPEgeneral" id="TYPEgeneral"><span class="keyword">type</span> <code class="type"></code>general</a> </pre>


<pre><a href="#TYPEsoup" id="TYPEsoup"><span class="keyword">type</span> <code class="type"></code>soup</a> </pre>
<div class="info ">
"Phantom" types for use with <code class="code"><span class="keywordsign">'</span>a&nbsp;node</code>. See explanation below.<br>
<div class="toc"><p>Module contents</p><div class="links"><a class="hide-narrow" href="#">[Top]</a><br><br><a href="#2_Types">Types</a><br><a href="#2_Highlevelinterface">High-level interface</a><br><a href="#2_Options">Options</a><br><a href="#2_Earlytermination">Early termination</a><br><a href="#2_Elementaccess">Element access</a><br><a href="#2_Contentaccess">Content access</a><br><a href="#2_Elementarytraversals">Elementary traversals</a><br><a href="#2_Combinators">Combinators</a><br><a href="#2_Projection">Projection</a><br><a href="#2_Convenience">Convenience</a><br><a href="#2_Printing">Printing</a><br><a href="#2_Parsingsignals">Parsing signals</a><br><a href="#2_Equality">Equality</a><br><a href="#2_Mutation">Mutation</a><br><a href="#2_IO">I/O</a><br></div><br><br><a class="github hide-narrow" href="https://github.com/aantron/lambda-soup">GitHub</a></div></div>


<pre><a href="#TYPEnode" id="TYPEnode"><span class="keyword">type</span> <code class="type">'a</code> node</a> </pre>
<div class="info ">
HTML nodes. These come in three varieties: <code class="code">element&nbsp;node</code> represents a node
    that is known to be an element, <code class="code">soup&nbsp;node</code> represents an entire document,
    and <code class="code">general&nbsp;node</code> represents a node that might be anything, including an
    element, a document, or text. There is no phantom type specifically for text
    nodes.
<p>

    Throughout Lambda Soup, if a function can operate on any kind of node, the
    argument is typed at <code class="code"><span class="keywordsign">'</span>a&nbsp;node</code>. If an element node or the entire document is
    required, the argument type is <code class="code">element&nbsp;node</code> or <code class="code">soup&nbsp;node</code>,
    respectively. <code class="code">general&nbsp;node</code> is the result of a function that can't
    guarantee that it evaluates to only elements or only documents.<br>
</p></div>


<pre><a href="#TYPEnodes" id="TYPEnodes"><span class="keyword">type</span> <code class="type">'a</code> nodes</a> </pre>
<div class="info ">
Sequence of nodes. This is always instantiated as either <code class="code">element&nbsp;nodes</code> or
    or <code class="code">general&nbsp;nodes</code>. The sequence is <em>lazy</em> in the sense that only as many
    elements as needed are evaluated. This can be used with <a href="#VALwith_stop"><code class="code">with_stop</code></a> to
    traverse part of a document until some condition is met.<br>
</div>


<h2 id="2_Highlevelinterface"><a href="#2_Highlevelinterface">High-level interface</a></h2>

<pre><a href="#VALparse" id="VALparse"><span class="keyword">val</span> parse</a> : <code class="type">string -&gt; <a href="#TYPEsoup">soup</a> <a href="#TYPEnode">node</a></code></pre><div class="info ">
Parses the given HTML and produces a document node. Entity references are
    resolved. The character encoding is detected automatically.
<p>

    If you need to parse XML, want finer control over parsing, or want to feed
    Lambda Soup something other than bytes, see <a href="#2_Parsingsignals"> Parsing
    signals</a>.<br>
</p></div>

<pre><a href="#VALselect" id="VALselect"><span class="keyword">val</span> select</a> : <code class="type">string -&gt; 'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">select&nbsp;selector&nbsp;node</code> is all the descendants of <code class="code">node</code> matching CSS
    selector <code class="code">selector</code>. All
    <a href="http://www.w3.org/TR/selectors/#selectors"> CSS3 selectors</a> are
    supported, except those which imply layout or a user interface:
<p>

</p><pre class="codepre"><code class="code">:link, :visited, :hover, :active, :focus, :target, :lang, :enabled,
:disabled, :checked, :indeterminate, ::first-line, ::first-letter,
::selection, ::before, ::after
</code></pre>
<p>

    XML namespace selectors are not supported. Lambda Soup supports the canceled
    <a href="http://www.w3.org/TR/2001/CR-css3-selectors-20011113/#content-selectors">
    <code class="code">:contains(<span class="string">"foo"</span>)</code></a> pseudo-class.
</p><p>

    In regular CSS, a selector cannot start with a combinator such as <code class="code">&gt;</code>.
    Lambda Soup allows selectors such as <code class="code">&gt;&nbsp;p</code>, <code class="code">+&nbsp;p</code>, and <code class="code">~&nbsp;p</code>, which select
    immediate children of <code class="code">node</code>, adjacent next siblings, and all next siblings,
    respectively.
</p><p>

    In addition, you can use the empty selector to select <code class="code">node</code> itself. In this
    case, note that if <code class="code">node</code> is not an element (for example, it is often the
    soup node), <code class="code">select</code> will result in nothing: <code class="code">select</code> always results in
    sequences of <em>element</em> nodes only.<br>
</p></div>

<pre><a href="#VALselect_one" id="VALselect_one"><span class="keyword">val</span> select_one</a> : <code class="type">string -&gt; 'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Like <code class="code">select</code>, but evaluates to at most one element. Note that there is also
    <code class="code"><span class="constructor">R</span>.select_one</code> if you don't want an optional result, which is explained at
    <a href="#VALrequire"><code class="code">require</code></a>.<br>
</div>

<pre><a href="#VAL($$)" id="VAL($$)"><span class="keyword">val</span> ($$)</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">node&nbsp;$$&nbsp;selector</code> is the same as <code class="code">select&nbsp;selector&nbsp;node</code>.<br>
</div>

<pre><a href="#VAL($?)" id="VAL($?)"><span class="keyword">val</span> ($?)</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
<code class="code">node&nbsp;$?&nbsp;selector</code> is the same as <code class="code">select_one&nbsp;selector&nbsp;node</code>.<br>
</div>

<pre><a href="#VAL($)" id="VAL($)"><span class="keyword">val</span> ($)</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a></code></pre><div class="info ">
<code class="code">node&nbsp;$&nbsp;selector</code> is the same as <code class="code">select_one&nbsp;selector&nbsp;node&nbsp;|&gt;&nbsp;require</code>.<br>
</div>

<pre><a href="#MODULEInfix" id="MODULEInfix"><span class="keyword">module</span> Infix</a> : <code class="code"><span class="keyword">sig</span></code> .. <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Open <code class="code"><span class="constructor">Soup</span>.<span class="constructor">Infix</span></code> instead of <code class="code"><span class="constructor">Soup</span></code> to introduce only the infix operators
    <code class="code">$$</code>, <code class="code">$?</code>, and <code class="code">$</code> into your scope.
</div>

<h2 id="2_Options"><a href="#2_Options">Options</a></h2>

<pre><a href="#VALrequire" id="VALrequire"><span class="keyword">val</span> require</a> : <code class="type">'a option -&gt; 'a</code></pre><div class="info ">
<code class="code">require&nbsp;(<span class="constructor">Some</span>&nbsp;v)</code> evaluates to <code class="code">v</code>, and <code class="code">require&nbsp;<span class="constructor">None</span></code> raises <code class="code"><span class="constructor">Failure</span></code>.<br>
</div>

<pre><a href="#MODULER" id="MODULER"><span class="keyword">module</span> R</a> : <code class="code"><span class="keyword">sig</span></code> .. <code class="code"><span class="keyword">end</span></code></pre><div class="info">
For each function <code class="code"><span class="constructor">Soup</span>.f</code> that evaluates to an option, <code class="code"><span class="constructor">Soup</span>.<span class="constructor">R</span>.f</code> is a
    version of <code class="code">f</code> that is post-composed with <code class="code">require</code>, so, for example, you
    can write <code class="code">soup&nbsp;|&gt;&nbsp;children&nbsp;|&gt;&nbsp;<span class="constructor">R</span>.first</code> instead of
    <code class="code">soup&nbsp;|&gt;&nbsp;children&nbsp;|&gt;&nbsp;first&nbsp;|&gt;&nbsp;require</code>.
</div>

<h2 id="2_Earlytermination"><a href="#2_Earlytermination">Early termination</a></h2>

<pre><code><a href="#TYPEstop" id="TYPEstop"><span class="keyword">type</span> <code class="type">'a</code> stop</a> = {</code></pre><table class="typetable">
<tbody><tr>
<td align="left" valign="top">
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top">
<code><a href="#TYPEELTstop.throw" id="TYPEELTstop.throw">throw</a>&nbsp;: <code class="type">'b. 'a -&gt; 'b</code>;</code></td>

</tr></tbody></table>
}

<div class="info ">
Used for early termination. See <a href="#VALwith_stop"><code class="code">with_stop</code></a> below.<br>
</div>


<pre><a href="#VALwith_stop" id="VALwith_stop"><span class="keyword">val</span> with_stop</a> : <code class="type">('a <a href="#TYPEstop">stop</a> -&gt; 'a) -&gt; 'a</code></pre><div class="info ">
<code class="code">with_stop&nbsp;(<span class="keyword">fun</span>&nbsp;stop&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;e)</code> behaves as <code class="code">e</code>. However, if the evaluation of
    <code class="code">e</code> calls <code class="code">stop.throw&nbsp;v</code>, the whole expression immediately evaluates to <code class="code">v</code>
    instead.
<p>

    For example, here is an expression that finds the first node with a
    <code class="code">draggable</code> attribute, stopping traversal immediately when that occurs:
</p><p>

</p><pre class="codepre"><code class="code">with_stop (<span class="keyword">fun</span> stop <span class="keywordsign">-&gt;</span>
  some_root_node
  |&gt; descendants
  |&gt; elements
  |&gt; iter (<span class="keyword">fun</span> element <span class="keywordsign">-&gt;</span>
    <span class="keyword">if</span> has_attribute <span class="string">"draggable"</span> element <span class="keyword">then</span>
      stop.throw (<span class="constructor">Some</span> element));
  <span class="constructor">None</span>)
</code></pre><br>
</div>

<h2 id="2_Elementaccess"><a href="#2_Elementaccess">Element access</a></h2>

<pre><a href="#VALname" id="VALname"><span class="keyword">val</span> name</a> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; string</code></pre><div class="info ">
The element's tag name. For example, an <code class="code">&lt;a&gt;</code> element has tag name <code class="code">a</code>. All
    tag names are converted to lowercase.<br>
</div>

<pre><a href="#VALattribute" id="VALattribute"><span class="keyword">val</span> attribute</a> : <code class="type">string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; string option</code></pre><div class="info ">
<code class="code">attribute&nbsp;attr&nbsp;element</code> retrieves the value of attribute <code class="code">attr</code> from the
    given element.<br>
</div>

<pre><a href="#VALclasses" id="VALclasses"><span class="keyword">val</span> classes</a> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; string list</code></pre><div class="info ">
The element's class list. For example, <code class="code">&lt;a&nbsp;<span class="keyword">class</span>=<span class="string">"foo&nbsp;bar"</span>&gt;</code> has class list
    <code class="code">[<span class="string">"foo"</span>;&nbsp;<span class="string">"bar"</span>]</code>.<br>
</div>

<pre><a href="#VALid" id="VALid"><span class="keyword">val</span> id</a> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; string option</code></pre><div class="info ">
The element's id.<br>
</div>

<pre><a href="#VALhas_attribute" id="VALhas_attribute"><span class="keyword">val</span> has_attribute</a> : <code class="type">string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
<code class="code">has_attribute&nbsp;attr&nbsp;element</code> indicates whether <code class="code">element</code> has attribute
    <code class="code">attr</code>.<br>
</div>

<pre><a href="#VALfold_attributes" id="VALfold_attributes"><span class="keyword">val</span> fold_attributes</a> : <code class="type">('a -&gt; string -&gt; string -&gt; 'a) -&gt; 'a -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; 'a</code></pre><div class="info ">
<code class="code">fold_attributes&nbsp;f&nbsp;init&nbsp;element</code> applies <code class="code">f</code> successively to the names and
    values of the attributes of <code class="code">element</code>. The first <code class="code">string</code> argument to <code class="code">f</code> is
    the attribute name, and the second is the value.<br>
</div>

<pre><a href="#VALelement" id="VALelement"><span class="keyword">val</span> element</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Given any node, asserts that it is an element <code class="code">e</code>. If so, evaluates to
    <code class="code"><span class="constructor">Some</span>&nbsp;e</code>. Otherwise, evaluates to <code class="code"><span class="constructor">None</span></code>.<br>
</div>

<pre><a href="#VALelements" id="VALelements"><span class="keyword">val</span> elements</a> : <code class="type">'a <a href="#TYPEnodes">nodes</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
Filters non-elements from a sequence of nodes.<br>
</div>

<pre><a href="#VALis_element" id="VALis_element"><span class="keyword">val</span> is_element</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
Indicates whether the given node is an element.<br>
</div>

<h2 id="2_Contentaccess"><a href="#2_Contentaccess">Content access</a></h2>

<pre><a href="#VALtexts" id="VALtexts"><span class="keyword">val</span> texts</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string list</code></pre><div class="info ">
<code class="code">texts&nbsp;node</code> is the content of all text nodes that are descendants of
    <code class="code">node</code>. If <code class="code">node</code> is itself a text node, evaluates to <code class="code">node</code>'s content.<br>
</div>

<pre><a href="#VALtrimmed_texts" id="VALtrimmed_texts"><span class="keyword">val</span> trimmed_texts</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string list</code></pre><div class="info ">
Same as <a href="#VALtexts"><code class="code">texts</code></a>, but all strings are passed through <code class="code"><span class="constructor">String</span>.trim</code>, and then
    all empty strings are filtered out.<br>
</div>

<pre><a href="#VALleaf_text" id="VALleaf_text"><span class="keyword">val</span> leaf_text</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string option</code></pre><div class="info ">
<code class="code">leaf_text&nbsp;node</code> retrieves the content of one text node in <code class="code">node</code>:
<p>
</p><ul>
<li>If <code class="code">node</code> is a text node itself, with value <code class="code">s</code>, <code class="code">leaf_text&nbsp;node</code>
      evaluates to <code class="code"><span class="constructor">Some</span>&nbsp;s</code>.</li>
<li>If <code class="code">node</code> is an element or soup node, then, <code class="code">leaf_text&nbsp;node</code> filters out
      all text children of <code class="code">node</code> containing only whitespace. If there is only
      one child <code class="code">child</code> remaining, it evaluates to <code class="code">leaf_text&nbsp;child</code>. If there
      are no children remaining, it evaluates to <code class="code"><span class="constructor">Some</span>&nbsp;<span class="string">""</span></code>. If there are two or
      more children remaining, it evaluates to <code class="code"><span class="constructor">None</span></code>.</li>
</ul>

    Here are some examples of what <code class="code">leaf_text</code> produces for various nodes:
<p>

</p><pre class="codepre"><code class="code">some text                                =&gt;   <span class="constructor">Some</span> <span class="string">"some text"</span>
&lt;p&gt;some text&lt;/p&gt;                         =&gt;   <span class="constructor">Some</span> <span class="string">"some text"</span>
&lt;div&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;              =&gt;   <span class="constructor">Some</span> <span class="string">"some text"</span>
&lt;div&gt; &lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;             =&gt;   <span class="constructor">Some</span> <span class="string">"some text"</span>
&lt;div&gt;&lt;p&gt;some text&lt;/p&gt;&lt;p&gt;more&lt;/p&gt;&lt;/div&gt;   =&gt;   <span class="constructor">None</span>
&lt;div&gt;&lt;/div&gt;                              =&gt;   <span class="constructor">Some</span> <span class="string">""</span>
</code></pre><br>
</div>

<h2 id="2_Elementarytraversals"><a href="#2_Elementarytraversals">Elementary traversals</a></h2>

<pre><a href="#VALchildren" id="VALchildren"><span class="keyword">val</span> children</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">children&nbsp;node</code> is the sequence of all children of <code class="code">node</code>. If <code class="code">node</code> is a
    text node, the traversal is empty.<br>
</div>

<pre><a href="#VALdescendants" id="VALdescendants"><span class="keyword">val</span> descendants</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">descendants&nbsp;node</code> is the sequence of all descendants of <code class="code">node</code>. <code class="code">node</code> is
    not considered to be its own descendant. If <code class="code">node</code> is a text node, the
    traversal is empty.<br>
</div>

<pre><a href="#VALancestors" id="VALancestors"><span class="keyword">val</span> ancestors</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">ancestors&nbsp;node</code> is the sequence of all ancestors of <code class="code">node</code>. <code class="code">node</code> is not
    considered to be its own ancestor. The soup node is not included. Ancestors
    are ordered by proximity to <code class="code">node</code>, i.e. the sequence goes up the DOM tree
    to a root element.<br>
</div>

<pre><a href="#VALsiblings" id="VALsiblings"><span class="keyword">val</span> siblings</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">siblings&nbsp;node</code> is the sequence of all siblings of <code class="code">node</code>. <code class="code">node</code> is not
    considered to be its own sibling. The siblings are ordered as they appear in
    the child list of <code class="code">node</code>'s parent.<br>
</div>

<pre><a href="#VALnext_siblings" id="VALnext_siblings"><span class="keyword">val</span> next_siblings</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
Like <a href="#VALsiblings"><code class="code">siblings</code></a>, but only those siblings which follow <code class="code">node</code> in its
    parent's child list.<br>
</div>

<pre><a href="#VALprevious_siblings" id="VALprevious_siblings"><span class="keyword">val</span> previous_siblings</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
Like <a href="#VALsiblings"><code class="code">siblings</code></a>, but only those siblings which precede <code class="code">node</code> in its
    parent's child list, and ordered by proximity to <code class="code">node</code>, i.e. the reverse
    order of appearance in <code class="code">node</code>'s parent's child list.<br>
</div>

<h2 id="2_Combinators"><a href="#2_Combinators">Combinators</a></h2>

<pre><a href="#VALfold" id="VALfold"><span class="keyword">val</span> fold</a> : <code class="type">('a -&gt; 'b <a href="#TYPEnode">node</a> -&gt; 'a) -&gt; 'a -&gt; 'b <a href="#TYPEnodes">nodes</a> -&gt; 'a</code></pre><div class="info ">
<code class="code">fold&nbsp;f&nbsp;init&nbsp;s</code> folds <code class="code">f</code> over the nodes of <code class="code">s</code>, i.e. if <code class="code">s</code> is
    <code class="code">n,&nbsp;n',&nbsp;n'',&nbsp;...</code>, evaluates <code class="code">f&nbsp;(f&nbsp;(f&nbsp;init&nbsp;n)&nbsp;n')&nbsp;n''&nbsp;...</code>.<br>
</div>

<pre><a href="#VALfilter" id="VALfilter"><span class="keyword">val</span> filter</a> : <code class="type">('a <a href="#TYPEnode">node</a> -&gt; bool) -&gt; 'a <a href="#TYPEnodes">nodes</a> -&gt; 'a <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">filter&nbsp;f&nbsp;s</code> is the sequence consisting of the nodes <code class="code">n</code> of <code class="code">s</code> for which
    <code class="code">f&nbsp;n</code> evaluates to <code class="code"><span class="keyword">true</span></code>.<br>
</div>

<pre><a href="#VALmap" id="VALmap"><span class="keyword">val</span> map</a> : <code class="type">('a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a>) -&gt; 'a <a href="#TYPEnodes">nodes</a> -&gt; 'b <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">map&nbsp;f&nbsp;s</code> is the sequence consisting of nodes <code class="code">f&nbsp;n</code> for each node <code class="code">n</code> of
    <code class="code">s</code>.<br>
</div>

<pre><a href="#VALfilter_map" id="VALfilter_map"><span class="keyword">val</span> filter_map</a> : <code class="type">('a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a> option) -&gt; 'a <a href="#TYPEnodes">nodes</a> -&gt; 'b <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">filter_map&nbsp;f&nbsp;s</code> is the sequence consisting of nodes <code class="code">n'</code> for each node <code class="code">n</code>
    of <code class="code">s</code> for which <code class="code">f&nbsp;n</code> evaluates to <code class="code"><span class="constructor">Some</span>&nbsp;n'</code>. Nodes for which <code class="code">f&nbsp;n</code>
    evaluates to <code class="code"><span class="constructor">None</span></code> are dropped.<br>
</div>

<pre><a href="#VALflatten" id="VALflatten"><span class="keyword">val</span> flatten</a> : <code class="type">('a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnodes">nodes</a>) -&gt; 'a <a href="#TYPEnodes">nodes</a> -&gt; 'b <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">flatten&nbsp;f&nbsp;s</code> is the sequence consisting of the concatenation of all the
    sequences <code class="code">f&nbsp;n</code> for each <code class="code">n</code> in <code class="code">s</code>.<br>
</div>

<pre><a href="#VALiter" id="VALiter"><span class="keyword">val</span> iter</a> : <code class="type">('a <a href="#TYPEnode">node</a> -&gt; unit) -&gt; 'a <a href="#TYPEnodes">nodes</a> -&gt; unit</code></pre><div class="info ">
<code class="code">iter&nbsp;f&nbsp;s</code> applies <code class="code">f</code> to each node in <code class="code">s</code>.<br>
</div>

<pre><a href="#VALrev" id="VALrev"><span class="keyword">val</span> rev</a> : <code class="type">'a <a href="#TYPEnodes">nodes</a> -&gt; 'a <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
Reverses the given node sequence. Note that this forces traversal of the
    sequence.<br>
</div>

<pre><a href="#VALto_list" id="VALto_list"><span class="keyword">val</span> to_list</a> : <code class="type">'a <a href="#TYPEnodes">nodes</a> -&gt; 'a <a href="#TYPEnode">node</a> list</code></pre><div class="info ">
Converts the given node sequence to a list.<br>
</div>

<h2 id="2_Projection"><a href="#2_Projection">Projection</a></h2>

<pre><a href="#VALnth" id="VALnth"><span class="keyword">val</span> nth</a> : <code class="type">int -&gt; 'a <a href="#TYPEnodes">nodes</a> -&gt; 'a <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
<code class="code">nth&nbsp;n&nbsp;s</code> evaluates to the <code class="code">n</code>th member of <code class="code">s</code>, if it is present. The index
    is 1-based. This is for consistency with the CSS <code class="code">:nth-child</code> selectors.<br>
</div>

<pre><a href="#VALfirst" id="VALfirst"><span class="keyword">val</span> first</a> : <code class="type">'a <a href="#TYPEnodes">nodes</a> -&gt; 'a <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Evaluates to the first node of the given sequence.<br>
</div>

<pre><a href="#VALlast" id="VALlast"><span class="keyword">val</span> last</a> : <code class="type">'a <a href="#TYPEnodes">nodes</a> -&gt; 'a <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Evaluates the entire given sequence and returns the last node.<br>
</div>

<pre><a href="#VALcount" id="VALcount"><span class="keyword">val</span> count</a> : <code class="type">'a <a href="#TYPEnodes">nodes</a> -&gt; int</code></pre><div class="info ">
Evaluates the entire given sequence and then returns the number of nodes.<br>
</div>

<pre><a href="#VALindex_of" id="VALindex_of"><span class="keyword">val</span> index_of</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; int</code></pre><div class="info ">
Evaluates to the index of the given node in its parent's child list. If the
    node has no parent, the index is 1. The index is 1-based, according to CSS
    convention.<br>
</div>

<pre><a href="#VALindex_of_element" id="VALindex_of_element"><span class="keyword">val</span> index_of_element</a> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; int</code></pre><div class="info ">
Evaluates to the element index of the given element in the parent's child
    list. That is, the index of the given element when the parent's non-element
    children are disregarded. The index is 1-based, according to CSS
    convention.<br>
</div>

<h2 id="2_Convenience"><a href="#2_Convenience">Convenience</a></h2>

<pre><a href="#VALtags" id="VALtags"><span class="keyword">val</span> tags</a> : <code class="type">string -&gt; 'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
Evaluates to all descendant elements of the given node that have the given
    tag name. For example, <code class="code">some_root_node&nbsp;|&gt;&nbsp;tags&nbsp;<span class="string">"a"</span></code> is a sequence of all <code class="code">a</code>
    elements under <code class="code">some_root_node</code>. It is equivalent to
<p>

</p><pre class="codepre"><code class="code">some_root_node
|&gt; descendants |&gt; elements |&gt; filter (<span class="keyword">fun</span> e <span class="keywordsign">-&gt;</span> name e = <span class="string">"a"</span>)
</code></pre>
<p>

    and
</p><p>

</p><pre class="codepre"><code class="code">some_root_node $$ <span class="string">"a"</span>
</code></pre>
<p>

    Tag names are case-insensitive.<br>
</p></div>

<pre><a href="#VALtag" id="VALtag"><span class="keyword">val</span> tag</a> : <code class="type">string -&gt; 'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Like <a href="#VALtags"><code class="code">tags</code></a>, but evaluates to only the first element.<br>
</div>

<pre><a href="#VALparent" id="VALparent"><span class="keyword">val</span> parent</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Given a node, evaluates to its parent element, if it has one. Note that root
    nodes do not have a parent <em>element</em>, as their parent is the soup node.
    Equivalent to <code class="code">n&nbsp;|&gt;&nbsp;ancestors&nbsp;|&gt;&nbsp;first</code>.<br>
</div>

<pre><a href="#VALis_root" id="VALis_root"><span class="keyword">val</span> is_root</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
Indicates whether the given node is not a soup node, and either has no
    parent, or its parent is a soup node.<br>
</div>

<pre><a href="#VALchild" id="VALchild"><span class="keyword">val</span> child</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
<code class="code">child&nbsp;node</code> evaluates to <code class="code">node</code>'s first child. Equivalent to
    <code class="code">node&nbsp;|&gt;&nbsp;children&nbsp;|&gt;&nbsp;first</code>.<br>
</div>

<pre><a href="#VALchild_element" id="VALchild_element"><span class="keyword">val</span> child_element</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
<code class="code">child_element&nbsp;node</code> evaluates to <code class="code">node</code>'s first child element. Equivalent
    to <code class="code">node&nbsp;|&gt;&nbsp;children&nbsp;|&gt;&nbsp;elements&nbsp;|&gt;&nbsp;first</code>.<br>
</div>

<pre><a href="#VALnext_sibling" id="VALnext_sibling"><span class="keyword">val</span> next_sibling</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
<code class="code">next_sibling&nbsp;node</code> is the next sibling of <code class="code">node</code> in <code class="code">node</code>'s parent's child
    list. Equivalent to <code class="code">node&nbsp;|&gt;&nbsp;next_siblings&nbsp;|&gt;&nbsp;first</code>.<br>
</div>

<pre><a href="#VALprevious_sibling" id="VALprevious_sibling"><span class="keyword">val</span> previous_sibling</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Like <a href="#VALnext_sibling"><code class="code">next_sibling</code></a>, but for the preceding sibling instead.<br>
</div>

<pre><a href="#VALnext_element" id="VALnext_element"><span class="keyword">val</span> next_element</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
<code class="code">next_element&nbsp;node</code> is the next sibling of <code class="code">node</code> that is an element.
    Equivalent to <code class="code">n&nbsp;|&gt;&nbsp;next_siblings&nbsp;|&gt;&nbsp;elements&nbsp;|&gt;&nbsp;first</code>.<br>
</div>

<pre><a href="#VALprevious_element" id="VALprevious_element"><span class="keyword">val</span> previous_element</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Like <a href="#VALnext_element"><code class="code">next_element</code></a>, but for the preceding siblings instead.<br>
</div>

<pre><a href="#VALno_children" id="VALno_children"><span class="keyword">val</span> no_children</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
Indicates whether the given node has no child nodes.<br>
</div>

<pre><a href="#VALat_most_one_child" id="VALat_most_one_child"><span class="keyword">val</span> at_most_one_child</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
Indicates whether the given node has at most one child node.<br>
</div>

<h2 id="2_Printing"><a href="#2_Printing">Printing</a></h2>

<pre><a href="#VALto_string" id="VALto_string"><span class="keyword">val</span> to_string</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string</code></pre><div class="info ">
Converts the node tree rooted at the given node to an HTML5 string,
    preserving whitespace nodes.<br>
</div>

<pre><a href="#VALpretty_print" id="VALpretty_print"><span class="keyword">val</span> pretty_print</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string</code></pre><div class="info ">
Converts the node tree rooted at the given node to an HTML5 string formatted
    for easy reading by humans, difference algorthims, etc.
<p>

    Note that this can change the whitespace structure of the HTML, so it may
    display differently in a browser than the original parsed document.<br>
</p></div>

<h2 id="2_Parsingsignals"><a href="#2_Parsingsignals">Parsing signals</a></h2>
<p>

    Lambda Soup uses <a href=" https://github.com/aantron/markup.ml"> Markup.ml</a>
    internally to parse and write markup. If you wish to:
</p><p>
</p><ul>
<li>scrape HTML output of some process without first writing it to a string,</li>
<li>scrape XML,</li>
<li>have fine control over how parsing is done, such as encoding selection, or</li>
<li>run the input or output of Lambda Soup through streaming filters,</li>
</ul>

    then you should use the functions below instead of <a href="#VALparse"><code class="code">parse</code></a> and
    <a href="#VALto_string"><code class="code">to_string</code></a>.
<p class="end-of-section-text">

    See the <a href="http://aantron.github.io/markup.ml/"> Markup.ml documentation</a> for
    a description of the types involved. The
    <a href="https://github.com/aantron/markup.ml#overview-and-basic-usage"> Markup.ml
    overview</a> may be a good place to start.<br>

</p><pre><a href="#VALsignals" id="VALsignals"><span class="keyword">val</span> signals</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; (Markup.signal, Markup.sync) Markup.stream</code></pre><div class="info ">
Converts the node tree rooted at the given node to a stream of Markup.ml
    signals. This underlies <a href="#VALto_string"><code class="code">to_string</code></a> and <a href="#VALpretty_print"><code class="code">pretty_print</code></a>.
<p>

    For example, you can use this function together with
    <a href="http://aantron.github.io/markup.ml/#VALwrite_xml"> <code class="code"><span class="constructor">Markup</span>.write_xml</code></a> to
    output XML, instead of HTML:
</p><p>

</p><pre class="codepre"><code class="code">soup |&gt; signals |&gt; <span class="constructor">Markup</span>.write_xml |&gt; <span class="constructor">Markup</span>.to_string
</code></pre><br>
</div>

<pre><a href="#VALfrom_signals" id="VALfrom_signals"><span class="keyword">val</span> from_signals</a> : <code class="type">(Markup.signal, Markup.sync) Markup.stream -&gt; <a href="#TYPEsoup">soup</a> <a href="#TYPEnode">node</a></code></pre><div class="info ">
Converts a stream of Markup.ml signals to a Lambda Soup document. This
    underlies <a href="#VALparse"><code class="code">parse</code></a>.
<p>

    For example, you can use this function together with
    <a href="http://aantron.github.io/markup.ml/#VALparse_xml"> <code class="code"><span class="constructor">Markup</span>.parse_xml</code></a> to
    load XML into Lambda Soup:
</p><p>

</p><pre class="codepre"><code class="code"><span class="constructor">Markup</span>.string s |&gt; <span class="constructor">Markup</span>.parse_xml |&gt; <span class="constructor">Markup</span>.signals |&gt; from_signals
</code></pre>
<p>

    Namespaces are ignored at the moment.<br>
</p></div>

<h2 id="2_Equality"><a href="#2_Equality">Equality</a></h2>

<pre><a href="#VALequal" id="VALequal"><span class="keyword">val</span> equal</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
<code class="code">equal&nbsp;n&nbsp;n'</code> recursively tests the node trees rooted at <code class="code">n</code> and <code class="code">n'</code> for
    equality. To test <code class="code"><span class="keyword">true</span></code>, the trees must be identical, including whitespace
    text nodes. Class attributes and other multi-valued attributes are compared
    literally: classes must be listed in the same order, with the same amount of
    whitespace in the attribute value. For the purposes of comparison, adjacent
    text nodes are merged, and empty text nodes are ignored: this is the
    standard HTML normalization procedure.<br>
</div>

<pre><a href="#VALequal_modulo_whitespace" id="VALequal_modulo_whitespace"><span class="keyword">val</span> equal_modulo_whitespace</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
<code class="code">equal_modulo_whitespace&nbsp;n&nbsp;n'</code> is like <code class="code">equal&nbsp;n&nbsp;n'</code>, but all text nodes have
    their values passed through <code class="code"><span class="constructor">String</span>.trim</code>. Text nodes that become empty are
    then ignored for the purpose of comparison, as in <code class="code">equal</code>.<br>
</div>

<h2 id="2_Mutation"><a href="#2_Mutation">Mutation</a></h2>

<pre><a href="#VALcreate_element" id="VALcreate_element"><span class="keyword">val</span> create_element</a> : <code class="type">?id:string -&gt;<br>       ?class_:string -&gt;<br>       ?classes:string list -&gt;<br>       ?attributes:(string * string) list -&gt;<br>       ?inner_text:string -&gt; string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a></code></pre><div class="multiline-member info">
<code class="code">create_element&nbsp;tag</code> creates a new element with the name <code class="code">tag</code>.
<p>

    If <code class="code">~attributes</code> is specified, the given attributes are added to the
    element. <code class="code">~attributes</code> defaults to <code class="code">[]</code>.
</p><p>

    If <code class="code">~classes</code> is specified, the class names are concatenated into a single
    string <code class="code">s</code> and the <code class="code"><span class="keyword">class</span></code> attribute is set on the element to the resulting
    value. This takes precedence over <code class="code">~attributes</code>.
</p><p>

    If <code class="code">~<span class="keyword">class</span></code> is specified, the class is set on the element. This takes
    precedence over both <code class="code">~attributes</code> and <code class="code">~classes</code>.
</p><p>

    If <code class="code">~id</code> is specified, the id is set. This takes precedence over
    <code class="code">~attributes</code>.
</p><p>

    If <code class="code">~inner_text</code> is specified, a text node is created with the given string,
    and made the single child of the new element.<br>
</p></div>

<pre><a href="#VALcreate_text" id="VALcreate_text"><span class="keyword">val</span> create_text</a> : <code class="type">string -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnode">node</a></code></pre><div class="info ">
Creates a new text node with the given content.<br>
</div>

<pre><a href="#VALcreate_soup" id="VALcreate_soup"><span class="keyword">val</span> create_soup</a> : <code class="type">unit -&gt; <a href="#TYPEsoup">soup</a> <a href="#TYPEnode">node</a></code></pre><div class="info ">
Creates a new empty document node.<br>
</div>

<pre><a href="#VALappend_child" id="VALappend_child"><span class="keyword">val</span> append_child</a> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; 'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">append_child&nbsp;element&nbsp;node</code> adds <code class="code">node</code> to the end of the child list of
    <code class="code">element</code>.<br>
</div>

<pre><a href="#VALprepend_child" id="VALprepend_child"><span class="keyword">val</span> prepend_child</a> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; 'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">prepend_child&nbsp;element&nbsp;node</code> adds <code class="code">node</code> to the beginning of the child list
    of <code class="code">element</code>.<br>
</div>

<pre><a href="#VALinsert_at_index" id="VALinsert_at_index"><span class="keyword">val</span> insert_at_index</a> : <code class="type">int -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; 'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">insert_at_index&nbsp;k&nbsp;element&nbsp;node</code> makes <code class="code">node</code> the <code class="code">k</code>th child of <code class="code">element</code>.
    Note that the index is 1-based. If <code class="code">k</code> is outside the range of current valid
    indices, <code class="code">node</code> is inserted at the beginning or end of <code class="code">element</code>'s child
    list.<br>
</div>

<pre><a href="#VALinsert_before" id="VALinsert_before"><span class="keyword">val</span> insert_before</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">insert_before&nbsp;node&nbsp;node'</code> inserts <code class="code">node'</code> immediately before <code class="code">node</code> in
    <code class="code">node</code>'s parent's child list.<br>
</div>

<pre><a href="#VALinsert_after" id="VALinsert_after"><span class="keyword">val</span> insert_after</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">insert_after&nbsp;node&nbsp;node'</code> inserts <code class="code">node'</code> immediately after <code class="code">node</code> in
    <code class="code">node</code>'s parent's child list.<br>
</div>

<pre><a href="#VALdelete" id="VALdelete"><span class="keyword">val</span> delete</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
Deletes the given node by unlinking it from its parent. If the node has
    descendants, they are implicitly deleted by this operation as well, in the
    sense that they become unreachable from the parent.<br>
</div>

<pre><a href="#VALclear" id="VALclear"><span class="keyword">val</span> clear</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
Unlinks all children of the given node.<br>
</div>

<pre><a href="#VALreplace" id="VALreplace"><span class="keyword">val</span> replace</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">replace&nbsp;node&nbsp;node'</code> replaces <code class="code">node</code> with <code class="code">node'</code> in <code class="code">node</code>'s parent's child
    list. All descendants of <code class="code">node</code> are implicitly deleted by this operation,
    because they become unreachable from <code class="code">node</code>'s parent.<br>
</div>

<pre><a href="#VALswap" id="VALswap"><span class="keyword">val</span> swap</a> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">swap&nbsp;element&nbsp;element'</code> replaces <code class="code">element</code> with <code class="code">element'</code> in <code class="code">element</code>'s
    parent's child list. All children of <code class="code">element</code> are transferred to
    <code class="code">element'</code>, and all original children of <code class="code">element'</code> are transferred to
    <code class="code">element</code>.<br>
</div>

<pre><a href="#VALwrap" id="VALwrap"><span class="keyword">val</span> wrap</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">wrap&nbsp;node&nbsp;element</code> inserts <code class="code">element</code> in the place of <code class="code">node</code>, and then makes
    <code class="code">node</code> <code class="code">element</code>'s child. All original children of <code class="code">element</code> are
    unlinked.<br>
</div>

<pre><a href="#VALunwrap" id="VALunwrap"><span class="keyword">val</span> unwrap</a> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">unwrap&nbsp;node</code> unlinks <code class="code">node</code>, and inserts all of <code class="code">node</code>'s children as
    children of <code class="code">node</code>'s parent at the former location of <code class="code">node</code>.<br>
</div>

<pre><a href="#VALappend_root" id="VALappend_root"><span class="keyword">val</span> append_root</a> : <code class="type"><a href="#TYPEsoup">soup</a> <a href="#TYPEnode">node</a> -&gt; 'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">append_root&nbsp;soup&nbsp;node</code> adds <code class="code">node</code> as the last root node of <code class="code">soup</code>.<br>
</div>

<pre><a href="#VALset_name" id="VALset_name"><span class="keyword">val</span> set_name</a> : <code class="type">string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
Sets the tag name of the given element.<br>
</div>

<pre><a href="#VALset_attribute" id="VALset_attribute"><span class="keyword">val</span> set_attribute</a> : <code class="type">string -&gt; string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">set_attribute&nbsp;attr&nbsp;value&nbsp;element</code> sets the value of attribute <code class="code">attr</code> on
    <code class="code">element</code> to <code class="code">value</code>. If the attribute is not present, it is added to
    <code class="code">element</code>. If it is already present, the value is replaced.<br>
</div>

<pre><a href="#VALdelete_attribute" id="VALdelete_attribute"><span class="keyword">val</span> delete_attribute</a> : <code class="type">string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
Removes the given attribute from the given element. If the attribute is not
    present, has no effect.<br>
</div>

<pre><a href="#VALadd_class" id="VALadd_class"><span class="keyword">val</span> add_class</a> : <code class="type">string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">add_class&nbsp;c&nbsp;element</code> adds class <code class="code">c</code> to <code class="code">element</code>, if <code class="code">element</code> does not
    already have class <code class="code">c</code>.<br>
</div>

<pre><a href="#VALremove_class" id="VALremove_class"><span class="keyword">val</span> remove_class</a> : <code class="type">string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">remove_class&nbsp;c&nbsp;element</code> removes class <code class="code">c</code> from <code class="code">element</code>, if <code class="code">element</code> has
    class <code class="code">c</code>.<br>
</div>

<h2 id="2_IO"><a href="#2_IO">I/O</a></h2>
<p>

    Lambda Soup is not an I/O library. However, it provides a few simple helpers
    based on standard I/O functions in
    <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#6_Inputoutput">
    <code class="code"><span class="constructor">Pervasives</span></code></a>. These should not be used for "serious" code. They are only
    for when you need to get something done quickly, and/or don't care about
    corner cases, concurrency, or excellent reliability. In such cases, they
    allow you to avoid writing I/O wrappers or using additional libraries.
</p><p>

    Using these, you can write little command-line scrapers and filters:
</p><p>

</p><pre class="codepre"><code class="code"><span class="keyword">let</span> () =
  <span class="keyword">let</span> soup = read_channel stdin |&gt; parse <span class="keyword">in</span>
  <span class="keyword">let</span> () = <span class="comment">(* ...do things to soup... *)</span> <span class="keyword">in</span>
  soup |&gt; to_string |&gt; write_channel stdout
</code></pre>
<p>

    If the above is compiled to a file <code class="code">scrape</code>, you can then run
</p><p>

</p><pre class="end-of-section-text codepre"><code class="code">curl -<span class="constructor">L</span> <span class="string">"http://location.com"</span> <span class="keywordsign">|</span> ./scrape
</code></pre>

<pre><a href="#VALread_file" id="VALread_file"><span class="keyword">val</span> read_file</a> : <code class="type">string -&gt; string</code></pre><div class="info ">
Reads the entire contents of the file with the given path. Raises
    <code class="code"><span class="constructor">Sys_error</span></code> on failure.<br>
</div>

<pre><a href="#VALread_channel" id="VALread_channel"><span class="keyword">val</span> read_channel</a> : <code class="type">Pervasives.in_channel -&gt; string</code></pre><div class="info ">
Reads all bytes from the given channel.<br>
</div>

<pre><a href="#VALwrite_file" id="VALwrite_file"><span class="keyword">val</span> write_file</a> : <code class="type">string -&gt; string -&gt; unit</code></pre><div class="info ">
<code class="code">write_file&nbsp;path&nbsp;data</code> writes <code class="code">data</code> to the file given by <code class="code">path</code>. If the
    file already exists, it is truncated (erased). If you want to append to
    file, use
    <a href=" http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALopen_out_gen">
    <code class="code">open_out_gen</code></a> with the necessary flags, and pass the resulting channel to
    <code class="code">write_channel</code>. Raises <code class="code"><span class="constructor">Sys_error</span></code> on failure.<br>
</div>

<pre><a href="#VALwrite_channel" id="VALwrite_channel"><span class="keyword">val</span> write_channel</a> : <code class="type">Pervasives.out_channel -&gt; string -&gt; unit</code></pre><div class="info ">
Writes the given data to the given channel.<br>
</div>
<div class="footer">
  Copyright © 2016 Anton Bachin. Released under the BSD 2-clause license.
  See
  <a href="https://github.com/aantron/lambda-soup/blob/master/docs/LICENSE">
    LICENSE
  </a>
  <br>
  This page is part of the documentation for
  <a href="https://github.com/aantron/lambda-soup">Lambda Soup</a>.
</div>
</body></html>